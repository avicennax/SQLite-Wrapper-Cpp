	===========================================================================================	
			SQLite-Wrapper: A simple C++ Wrapper for sqlite3 API
	===========================================================================================
		
		-- Introduction --	
		
	The 'Database' class provides a C++ wrapper object for SQL databases, that allows developers
	to load, access and query a database via 'Database' member functions.
	The 'Database' class provides two major avenues for SQL database queries: queryDB() and
	four specialized query member functions, selectDB(), insertDB(), updateDB() and deleteDB().
	The queryDB() method takes a single std::string parameter, which is a syntactically and
	semantically complete SQL query, and runs it against the target database.
	The four specialized query methods take set(s) of std::vector<string> and std::string
	parameters containing values relevant to the query. These methods are best used when query
	values are derived from	external sources, thus removing the need to construct ones own
	syntactically complete query statements. 
	
	SELECT queries executed from either queryDB() or selectDB() will store the returned table
	in a std::vector<vector<string>> (multidimensional string vector), queryResults, and print
	the table via std::cout if specified.
	
	Furthermore, two functions texQuo() and expBuild() are provided to assist the 
	developer in building std::string parameters ready for passing to 'Database' methods.
	

		-- Overview --
		
	Public methods will return the following range of values signifying the respective information.
	
	Error Codes:
		0: successful.
		1: exec() failed.
		2: empty string.
		3: database not loaded.
		4: query parameter mismatch
		5: invalid verbose value

	- int verbose
	=============
		Represents 'Database' object's reporting status.
		0: silent
		1: errors
		2: verbose
	
		1(silent) will only return error codes, 2(errors) will pass error messages to std::cout,
		and 3(verbose) will report the status of all operations, successful or error generating
		to std::cout.
	
	- std::vector<vector<std::string>> queryResults
	===============================================
		The queryResults vector is reset and emptied prior to each query operation.
		The representation of the table in queryResults mirrors the printed format.
		Column header names are stored in queryResults[0][n] where 'n' represents the number of
		columns in the table, and records are identified by row number, starting at 1.
		
		Ex:	queryResults contains 3 records and 4 columns.
		Columns - [0][0]: id, [0][1]: name,  [0][2]: age, [0][3]: gender
		Records - [1[[0]: 1,  [1][1]: John,  [1][2]: 23,  [1][3]: Male
			- [2][0]: 2,  [2][1]: Sarah, [2][2]: 19,  [2][3]: Female
			- [3][0]: 3,  [3][1]: Mike,  [3][2]: 25,  [3][3]: Male

		Accessing the name field of record #1: queryResults[1][1]
		Accessing the 3rd column name: queryResults[0][2]
		Accessing Sarah's ID: queryResults[2][0]


	- Database(int verbose=1, string databaseName=string()
	======================================================
		Initializes 'Database' object state. Sets Database::verbose to the value of the verbose
		parameter (optional), and/or passes databaseName to loadDB() (optional).
	
	- int setReportStatus(int verbose)
	==================================
		Sets Database::verbose to the value of the verbose parameter.
	
	- int loadDB(string databaseName)
	=================================
		sqlite3 code will search for a file path/file of the character sequence in databaseName.
		If the SQL database cannot be found then a database will be generated in the local directory
		with a file name in exact likeness of the character sequence in databaseName.
		As such, the databaseName parameter must contain the file extension of the target database
		in order to be identified by the sqlite3 engine code.
	
	- int listTables()
	==================
		Stores names of tables in queryResults as 1-dimensional vector.
		If verbose equal to 2, then the table is also printed via std::cout.
		
	- int createTable(string tableName, vector<string> columns, string key=string())
	================================================================================
		CREATE query is constructed as follows:
	
		CREATE TABLE /tableName/ (
			/key/ PRIMARY KEY,
			/columns[0]/,
			/columns[1]/,		
			/columns[2]/,
				..,
			/columns[n]/	// [n] is the number of columns - 1
		);
		
		NOTE: std::string key is optional, in the event no string is provided the table will be
		constructed without a PRIMARY KEY field.

	- int dropTable(string tableName)
	=================================
		--
	
	- int queryDB(string query)
	===========================
		The 'query' std::string is passed almost directly to sqlite3 execution code without any
		semantic or syntactically intervention. So as stated in the introduction the query should
		be a semantically and syntactically complete SQL query statement.
		
		Tables generated by SELECT queries are stored in queryResults, and printed via std::cout
		if Database::verbose is equal to 2.

		
	- int selectDB(vector<string> columns, vector<string> tables, vector<string>
	predicates=vector<string>(), vector<string> predBools=vector<string>())
	=======================================================================
		SELECT query is constructed as follows:
		
		SELECT /columns[0]/, .. , /columns[n]/ FROM /tables[0]/, .. , /tables[n]/ 
		WHERE /predicates[0]/ /predBools[0]/ /predicates[1]/ .. /predBools[n]/ /predicates[n]/;
		
		// [n] is the respective vector sizes + 1
		
		This is query assumes that all parameters are utilized.
		Other constructions include:
		
		SELECT /columns[0]/, .. , /columns[n]/ FROM /tables[0]/, .. , /tables[n]/;
		
		SELECT /columns[0]/, .. , /columns[n]/ FROM /tables[0]/, .. , /tables[n] WHERE /predicates[0]/;
		
		Tables generated by this query call are stored in queryResults, and printed via std::cout
		if Database::verbose is equal to 2.
		

	- int insertDB(string tableName, vector<string> values, vector<string> paramOrder=vector<string>())
	===================================================================================================
		INSERT query is constructed as follows:
		
		INSERT INTO /tableName/ (/paramOrder[0]/, .. , /paramOrder[n]/)
		VALUES (/values[0]/, .. , /values[n]/);
		
		If the paramOrder vector is not used the construction is as follows:
		
		INSERT INTO /tableName/ VALUES (/values[0]/, .. , /values[n]/);
		

	- int updateDB(string tableName, vector<string> setClauses, vector<string> predicates, 
	vector<string> predBools=vector<string>());
	===========================================
		UPDATE query is constructed as follows:
		
		UPDATE /tableName/ SET /setClauses[0]/, .. , /setClauses[n]/ 
		WHERE /predicates[0]/ /predBools[0]/ /predicates[1]/ .. /predBools[n]/ /predicates[n]/;
		
		If the predBools vector is not used the construction is as follows:
		
		UPDATE /tableName/ SET /setClauses[0]/, .. , /setClauses[n]/ WHERE /predicates[0]/;
		
	
	- int deleteDB(string tableName, vector<string> predicates, vector<string> predBools=vector<string>());
	=======================================================================================================
		DELETE query is constructed as follows:
		
		DELETE /tableName/
		WHERE /predicates[0]/ /predBools[0]/ /predicates[1]/ .. /predBools[n]/ /predicates[n]/;
		
		If the predBools vector is not used the construction is as follows:
		
		DELETE /tableName/ WHERE /predicates[0]/;	
	
	
	*Created 8/4/14
			
		
	
	
		
	
	
	
	
	
	
		
		
	
	